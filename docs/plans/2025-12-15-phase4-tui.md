# Phase 4: TUI - Implementation Plan

> **For Claude:** Implement this plan task-by-task.

**Goal:** Add interactive terminal UI for browsing and posting.

**Architecture:** Bubble Tea three-pane layout with Lip Gloss styling.

**Tech Stack:** charmbracelet/bubbletea, charmbracelet/lipgloss, charmbracelet/bubbles

---

## Task 1: TUI Dependencies and App Skeleton

**Files:**
- Create: `internal/tui/app.go`

**Step 1: Add dependencies**

Run: `go get github.com/charmbracelet/bubbletea github.com/charmbracelet/lipgloss github.com/charmbracelet/bubbles`

**Step 2: Create app.go**

```go
// ABOUTME: Main Bubble Tea application model
// ABOUTME: Coordinates three-pane layout and navigation

package tui

import (
	"database/sql"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// Pane represents which pane is focused
type Pane int

const (
	TopicsPane Pane = iota
	ThreadsPane
	MessagesPane
)

// Model is the main application state
type Model struct {
	db          *sql.DB
	identity    string
	activePane  Pane
	width       int
	height      int
	topics      TopicsModel
	threads     ThreadsModel
	messages    MessagesModel
	composing   bool
	composeText string
	err         error
}

// NewModel creates a new TUI model
func NewModel(db *sql.DB, identity string) Model {
	return Model{
		db:         db,
		identity:   identity,
		activePane: TopicsPane,
		topics:     NewTopicsModel(db),
		threads:    NewThreadsModel(db),
		messages:   NewMessagesModel(db),
	}
}

// Init initializes the model
func (m Model) Init() tea.Cmd {
	return m.topics.LoadTopics()
}

// Update handles messages
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		if m.composing {
			return m.updateCompose(msg)
		}
		return m.updateNavigation(msg)

	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		return m, nil

	case TopicsLoadedMsg:
		m.topics.SetTopics(msg.Topics)
		return m, nil

	case ThreadsLoadedMsg:
		m.threads.SetThreads(msg.Threads)
		return m, nil

	case MessagesLoadedMsg:
		m.messages.SetMessages(msg.Messages)
		return m, nil

	case error:
		m.err = msg
		return m, nil
	}

	return m, nil
}

func (m Model) updateNavigation(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "q", "ctrl+c":
		return m, tea.Quit

	case "tab":
		m.activePane = (m.activePane + 1) % 3
		return m, nil

	case "shift+tab":
		m.activePane = (m.activePane + 2) % 3
		return m, nil

	case "j", "down":
		switch m.activePane {
		case TopicsPane:
			m.topics.MoveDown()
		case ThreadsPane:
			m.threads.MoveDown()
		case MessagesPane:
			m.messages.MoveDown()
		}
		return m, nil

	case "k", "up":
		switch m.activePane {
		case TopicsPane:
			m.topics.MoveUp()
		case ThreadsPane:
			m.threads.MoveUp()
		case MessagesPane:
			m.messages.MoveUp()
		}
		return m, nil

	case "enter":
		switch m.activePane {
		case TopicsPane:
			if topic := m.topics.Selected(); topic != nil {
				m.activePane = ThreadsPane
				return m, m.threads.LoadThreads(topic.ID.String())
			}
		case ThreadsPane:
			if thread := m.threads.Selected(); thread != nil {
				m.activePane = MessagesPane
				return m, m.messages.LoadMessages(thread.ID.String())
			}
		}
		return m, nil

	case "n":
		m.composing = true
		m.composeText = ""
		return m, nil

	case "r":
		return m, m.topics.LoadTopics()
	}

	return m, nil
}

func (m Model) updateCompose(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "esc":
		m.composing = false
		return m, nil
	case "enter":
		// Submit compose
		m.composing = false
		return m, nil
	case "backspace":
		if len(m.composeText) > 0 {
			m.composeText = m.composeText[:len(m.composeText)-1]
		}
		return m, nil
	default:
		if len(msg.String()) == 1 {
			m.composeText += msg.String()
		}
		return m, nil
	}
}

// View renders the UI
func (m Model) View() string {
	if m.width == 0 {
		return "Loading..."
	}

	// Calculate pane widths
	topicsWidth := m.width / 4
	threadsWidth := m.width / 4
	messagesWidth := m.width - topicsWidth - threadsWidth

	// Styles
	activeStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("86"))

	inactiveStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("240"))

	// Render panes
	topicsStyle := inactiveStyle
	threadsStyle := inactiveStyle
	messagesStyle := inactiveStyle

	switch m.activePane {
	case TopicsPane:
		topicsStyle = activeStyle
	case ThreadsPane:
		threadsStyle = activeStyle
	case MessagesPane:
		messagesStyle = activeStyle
	}

	topicsView := topicsStyle.Width(topicsWidth - 2).Height(m.height - 4).Render(m.topics.View())
	threadsView := threadsStyle.Width(threadsWidth - 2).Height(m.height - 4).Render(m.threads.View())
	messagesView := messagesStyle.Width(messagesWidth - 2).Height(m.height - 4).Render(m.messages.View())

	main := lipgloss.JoinHorizontal(lipgloss.Top, topicsView, threadsView, messagesView)

	// Status bar
	status := lipgloss.NewStyle().
		Foreground(lipgloss.Color("241")).
		Render("[tab] switch pane  [j/k] navigate  [enter] select  [n] new  [r] refresh  [q] quit")

	if m.composing {
		status = lipgloss.NewStyle().
			Foreground(lipgloss.Color("86")).
			Render("Composing: " + m.composeText + "â–ˆ  [enter] submit  [esc] cancel")
	}

	return lipgloss.JoinVertical(lipgloss.Left, main, status)
}

// Run starts the TUI
func Run(db *sql.DB, identity string) error {
	p := tea.NewProgram(NewModel(db, identity), tea.WithAltScreen())
	_, err := p.Run()
	return err
}
```

**Step 3: Verify it compiles (will fail, need pane models)**

Run: `go build ./internal/tui/...`
Expected: Errors about undefined types (TopicsModel, etc.)

**Step 4: Commit skeleton**

```bash
git add internal/tui/app.go go.mod go.sum
git commit -m "feat: add TUI app skeleton with Bubble Tea"
```

---

## Task 2: Topics Pane

**Files:**
- Create: `internal/tui/topics.go`

**Implementation:**

```go
// ABOUTME: Topics pane component
// ABOUTME: Lists and navigates topics

package tui

import (
	"database/sql"
	"fmt"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/harper/bbs/internal/db"
	"github.com/harper/bbs/internal/models"
)

type TopicsLoadedMsg struct {
	Topics []*models.Topic
}

type TopicsModel struct {
	db       *sql.DB
	topics   []*models.Topic
	cursor   int
	selected int
}

func NewTopicsModel(database *sql.DB) TopicsModel {
	return TopicsModel{db: database, cursor: 0, selected: -1}
}

func (m *TopicsModel) LoadTopics() tea.Cmd {
	return func() tea.Msg {
		topics, err := db.ListTopics(m.db, false)
		if err != nil {
			return err
		}
		return TopicsLoadedMsg{Topics: topics}
	}
}

func (m *TopicsModel) SetTopics(topics []*models.Topic) {
	m.topics = topics
	if m.cursor >= len(topics) {
		m.cursor = len(topics) - 1
	}
	if m.cursor < 0 {
		m.cursor = 0
	}
}

func (m *TopicsModel) MoveUp() {
	if m.cursor > 0 {
		m.cursor--
	}
}

func (m *TopicsModel) MoveDown() {
	if m.cursor < len(m.topics)-1 {
		m.cursor++
	}
}

func (m *TopicsModel) Selected() *models.Topic {
	if m.cursor >= 0 && m.cursor < len(m.topics) {
		return m.topics[m.cursor]
	}
	return nil
}

func (m TopicsModel) View() string {
	if len(m.topics) == 0 {
		return lipgloss.NewStyle().Faint(true).Render("No topics")
	}

	var s string
	s += lipgloss.NewStyle().Bold(true).Render("Topics") + "\n\n"

	for i, topic := range m.topics {
		cursor := "  "
		style := lipgloss.NewStyle()

		if i == m.cursor {
			cursor = "> "
			style = style.Foreground(lipgloss.Color("86"))
		}

		archived := ""
		if topic.Archived {
			archived = " (archived)"
			style = style.Faint(true)
		}

		s += fmt.Sprintf("%s%s%s\n", cursor, style.Render(topic.Name), archived)
	}

	return s
}
```

**Step 2: Verify partial compile**

Run: `go build ./internal/tui/...`

**Step 3: Commit**

```bash
git add internal/tui/topics.go
git commit -m "feat: add topics pane component"
```

---

## Task 3: Threads Pane

**Files:**
- Create: `internal/tui/threads.go`

**Implementation:**

```go
// ABOUTME: Threads pane component
// ABOUTME: Lists and navigates threads in a topic

package tui

import (
	"database/sql"
	"fmt"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/harper/bbs/internal/db"
	"github.com/harper/bbs/internal/models"
)

type ThreadsLoadedMsg struct {
	Threads []*models.Thread
}

type ThreadsModel struct {
	db      *sql.DB
	threads []*models.Thread
	cursor  int
	topicID string
}

func NewThreadsModel(database *sql.DB) ThreadsModel {
	return ThreadsModel{db: database, cursor: 0}
}

func (m *ThreadsModel) LoadThreads(topicID string) tea.Cmd {
	m.topicID = topicID
	return func() tea.Msg {
		threads, err := db.ListThreads(m.db, topicID)
		if err != nil {
			return err
		}
		return ThreadsLoadedMsg{Threads: threads}
	}
}

func (m *ThreadsModel) SetThreads(threads []*models.Thread) {
	m.threads = threads
	m.cursor = 0
}

func (m *ThreadsModel) MoveUp() {
	if m.cursor > 0 {
		m.cursor--
	}
}

func (m *ThreadsModel) MoveDown() {
	if m.cursor < len(m.threads)-1 {
		m.cursor++
	}
}

func (m *ThreadsModel) Selected() *models.Thread {
	if m.cursor >= 0 && m.cursor < len(m.threads) {
		return m.threads[m.cursor]
	}
	return nil
}

func (m ThreadsModel) View() string {
	if len(m.threads) == 0 {
		return lipgloss.NewStyle().Faint(true).Render("No threads\n\nSelect a topic")
	}

	var s string
	s += lipgloss.NewStyle().Bold(true).Render("Threads") + "\n\n"

	for i, thread := range m.threads {
		cursor := "  "
		style := lipgloss.NewStyle()

		if i == m.cursor {
			cursor = "> "
			style = style.Foreground(lipgloss.Color("86"))
		}

		prefix := ""
		if thread.Sticky {
			prefix = "ðŸ“Œ "
		}

		s += fmt.Sprintf("%s%s%s\n", cursor, prefix, style.Render(thread.Subject))
		s += lipgloss.NewStyle().Faint(true).Render(fmt.Sprintf("   %s\n", thread.CreatedBy))
	}

	return s
}
```

**Step 2: Commit**

```bash
git add internal/tui/threads.go
git commit -m "feat: add threads pane component"
```

---

## Task 4: Messages Pane

**Files:**
- Create: `internal/tui/messages.go`

**Implementation:**

```go
// ABOUTME: Messages pane component
// ABOUTME: Displays messages in a thread

package tui

import (
	"database/sql"
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/harper/bbs/internal/db"
	"github.com/harper/bbs/internal/models"
)

type MessagesLoadedMsg struct {
	Messages []*models.Message
}

type MessagesModel struct {
	db       *sql.DB
	messages []*models.Message
	cursor   int
	scroll   int
	threadID string
}

func NewMessagesModel(database *sql.DB) MessagesModel {
	return MessagesModel{db: database, cursor: 0, scroll: 0}
}

func (m *MessagesModel) LoadMessages(threadID string) tea.Cmd {
	m.threadID = threadID
	return func() tea.Msg {
		messages, err := db.ListMessages(m.db, threadID)
		if err != nil {
			return err
		}
		return MessagesLoadedMsg{Messages: messages}
	}
}

func (m *MessagesModel) SetMessages(messages []*models.Message) {
	m.messages = messages
	m.cursor = 0
	m.scroll = 0
}

func (m *MessagesModel) MoveUp() {
	if m.scroll > 0 {
		m.scroll--
	}
}

func (m *MessagesModel) MoveDown() {
	if m.scroll < len(m.messages)-1 {
		m.scroll++
	}
}

func (m *MessagesModel) Selected() *models.Message {
	if m.cursor >= 0 && m.cursor < len(m.messages) {
		return m.messages[m.cursor]
	}
	return nil
}

func (m MessagesModel) View() string {
	if len(m.messages) == 0 {
		return lipgloss.NewStyle().Faint(true).Render("No messages\n\nSelect a thread")
	}

	var s string
	s += lipgloss.NewStyle().Bold(true).Render("Messages") + "\n\n"

	headerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("86"))
	faintStyle := lipgloss.NewStyle().Faint(true)

	for i, msg := range m.messages {
		if i < m.scroll {
			continue
		}

		// Header
		edited := ""
		if msg.EditedAt != nil {
			edited = " (edited)"
		}
		s += headerStyle.Render(msg.CreatedBy)
		s += faintStyle.Render(fmt.Sprintf(" Â· %s%s\n", msg.CreatedAt.Format("Jan 02 15:04"), edited))

		// Content (truncate long messages)
		content := msg.Content
		if len(content) > 200 {
			content = content[:200] + "..."
		}
		// Wrap content
		lines := strings.Split(content, "\n")
		for _, line := range lines {
			s += line + "\n"
		}
		s += "\n"
	}

	return s
}
```

**Step 2: Verify it compiles**

Run: `go build ./internal/tui/...`

**Step 3: Commit**

```bash
git add internal/tui/messages.go
git commit -m "feat: add messages pane component"
```

---

## Task 5: Wire TUI to Root Command

**Files:**
- Update: `cmd/bbs/root.go`

**Implementation:**

Update the root command to launch TUI when no subcommand is given:

```go
// Add to rootCmd in root.go:
RunE: func(cmd *cobra.Command, args []string) error {
	// Launch TUI if no subcommand
	return tui.Run(dbConn, identity.GetIdentity(identityFlag, "tui"))
},
```

Add import: `"github.com/harper/bbs/internal/tui"`

**Step 2: Build and verify**

Run: `go build ./cmd/bbs && ./bbs`
Expected: TUI launches

**Step 3: Commit**

```bash
git add cmd/bbs/root.go
git commit -m "feat: launch TUI when no subcommand given"
```

---

## Phase 4 Complete Checklist

- [ ] `go build ./cmd/bbs` succeeds
- [ ] `./bbs` launches TUI
- [ ] Tab switches panes
- [ ] j/k navigates
- [ ] Enter drills down
- [ ] q quits
