# Phase 2: CRUD Operations - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add database CRUD operations and CLI commands for topics, threads, and messages.

**Architecture:** Database layer functions + Cobra subcommands following toki patterns.

**Tech Stack:** Same as Phase 1, plus fatih/color for output formatting.

---

## Task 1: Topic Database Operations

**Files:**
- Create: `internal/db/topics.go`
- Create: `internal/db/topics_test.go`

**Step 1: Write failing test**

```go
// ABOUTME: Tests for topic database operations
// ABOUTME: Verifies CRUD operations for topics

package db

import (
	"path/filepath"
	"testing"

	"github.com/harper/bbs/internal/models"
)

func TestCreateTopic(t *testing.T) {
	db, err := InitDB(filepath.Join(t.TempDir(), "test.db"))
	if err != nil {
		t.Fatalf("InitDB failed: %v", err)
	}
	defer db.Close()

	topic := models.NewTopic("general", "General discussion", "harper@cli")
	err = CreateTopic(db, topic)
	if err != nil {
		t.Fatalf("CreateTopic failed: %v", err)
	}

	// Verify it was created
	got, err := GetTopicByID(db, topic.ID.String())
	if err != nil {
		t.Fatalf("GetTopicByID failed: %v", err)
	}
	if got.Name != "general" {
		t.Errorf("expected name 'general', got '%s'", got.Name)
	}
}

func TestListTopics(t *testing.T) {
	db, err := InitDB(filepath.Join(t.TempDir(), "test.db"))
	if err != nil {
		t.Fatalf("InitDB failed: %v", err)
	}
	defer db.Close()

	// Create two topics
	topic1 := models.NewTopic("general", "General", "harper@cli")
	topic2 := models.NewTopic("builds", "Build logs", "harper@cli")
	CreateTopic(db, topic1)
	CreateTopic(db, topic2)

	topics, err := ListTopics(db, false)
	if err != nil {
		t.Fatalf("ListTopics failed: %v", err)
	}
	if len(topics) != 2 {
		t.Errorf("expected 2 topics, got %d", len(topics))
	}
}

func TestArchiveTopic(t *testing.T) {
	db, err := InitDB(filepath.Join(t.TempDir(), "test.db"))
	if err != nil {
		t.Fatalf("InitDB failed: %v", err)
	}
	defer db.Close()

	topic := models.NewTopic("old-stuff", "Old", "harper@cli")
	CreateTopic(db, topic)

	err = ArchiveTopic(db, topic.ID.String(), true)
	if err != nil {
		t.Fatalf("ArchiveTopic failed: %v", err)
	}

	// Should not appear in non-archived list
	topics, _ := ListTopics(db, false)
	if len(topics) != 0 {
		t.Errorf("expected 0 non-archived topics, got %d", len(topics))
	}

	// Should appear in archived list
	topics, _ = ListTopics(db, true)
	if len(topics) != 1 {
		t.Errorf("expected 1 archived topic, got %d", len(topics))
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/db/... -run TestCreateTopic`
Expected: FAIL (undefined functions)

**Step 3: Write topics.go**

```go
// ABOUTME: Topic database operations
// ABOUTME: CRUD functions for topics table

package db

import (
	"database/sql"
	"fmt"
	"strings"

	"github.com/harper/bbs/internal/models"
)

// CreateTopic inserts a new topic into the database.
func CreateTopic(db *sql.DB, topic *models.Topic) error {
	_, err := db.Exec(`
		INSERT INTO topics (id, name, description, created_at, created_by, archived)
		VALUES (?, ?, ?, ?, ?, ?)`,
		topic.ID.String(), topic.Name, topic.Description,
		topic.CreatedAt, topic.CreatedBy, topic.Archived)
	return err
}

// GetTopicByID retrieves a topic by its UUID (supports prefix matching).
func GetTopicByID(db *sql.DB, id string) (*models.Topic, error) {
	query := `SELECT id, name, description, created_at, created_by, archived
			  FROM topics WHERE id = ? OR id LIKE ?`
	row := db.QueryRow(query, id, id+"%")
	return scanTopic(row)
}

// GetTopicByName retrieves a topic by its name.
func GetTopicByName(db *sql.DB, name string) (*models.Topic, error) {
	query := `SELECT id, name, description, created_at, created_by, archived
			  FROM topics WHERE name = ?`
	row := db.QueryRow(query, name)
	return scanTopic(row)
}

// ListTopics returns all topics, optionally filtering by archived status.
func ListTopics(db *sql.DB, includeArchived bool) ([]*models.Topic, error) {
	query := `SELECT id, name, description, created_at, created_by, archived
			  FROM topics`
	if !includeArchived {
		query += " WHERE archived = FALSE"
	}
	query += " ORDER BY name"

	rows, err := db.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var topics []*models.Topic
	for rows.Next() {
		topic, err := scanTopicFromRows(rows)
		if err != nil {
			return nil, err
		}
		topics = append(topics, topic)
	}
	return topics, rows.Err()
}

// ArchiveTopic sets the archived status of a topic.
func ArchiveTopic(db *sql.DB, id string, archived bool) error {
	result, err := db.Exec(`UPDATE topics SET archived = ? WHERE id = ? OR id LIKE ?`,
		archived, id, id+"%")
	if err != nil {
		return err
	}
	rows, _ := result.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("topic not found: %s", id)
	}
	return nil
}

// ResolveTopicID finds a topic by ID prefix or name, returning the full ID.
func ResolveTopicID(db *sql.DB, idOrName string) (string, error) {
	// Try by name first
	topic, err := GetTopicByName(db, idOrName)
	if err == nil {
		return topic.ID.String(), nil
	}

	// Try by ID prefix
	topic, err = GetTopicByID(db, idOrName)
	if err != nil {
		return "", fmt.Errorf("topic not found: %s", idOrName)
	}
	return topic.ID.String(), nil
}

func scanTopic(row *sql.Row) (*models.Topic, error) {
	var topic models.Topic
	var id string
	err := row.Scan(&id, &topic.Name, &topic.Description,
		&topic.CreatedAt, &topic.CreatedBy, &topic.Archived)
	if err != nil {
		return nil, err
	}
	topic.ID, _ = parseUUID(id)
	return &topic, nil
}

func scanTopicFromRows(rows *sql.Rows) (*models.Topic, error) {
	var topic models.Topic
	var id string
	err := rows.Scan(&id, &topic.Name, &topic.Description,
		&topic.CreatedAt, &topic.CreatedBy, &topic.Archived)
	if err != nil {
		return nil, err
	}
	topic.ID, _ = parseUUID(id)
	return &topic, nil
}

func parseUUID(s string) (uuid models.UUID, err error) {
	// Simple wrapper to handle UUID parsing
	return models.ParseUUID(s)
}
```

**Step 4: Add UUID parsing to models**

Add to `internal/models/models.go`:

```go
import "github.com/google/uuid"

type UUID = uuid.UUID

// ParseUUID parses a string into a UUID.
func ParseUUID(s string) (uuid.UUID, error) {
	return uuid.Parse(s)
}
```

**Step 5: Run test to verify it passes**

Run: `go test ./internal/db/... -v`
Expected: PASS

**Step 6: Commit**

```bash
git add internal/db/topics.go internal/db/topics_test.go internal/models/models.go
git commit -m "feat: add topic database operations"
```

---

## Task 2: Thread Database Operations

**Files:**
- Create: `internal/db/threads.go`
- Create: `internal/db/threads_test.go`

**Step 1: Write failing test**

```go
// ABOUTME: Tests for thread database operations
// ABOUTME: Verifies CRUD operations for threads

package db

import (
	"path/filepath"
	"testing"

	"github.com/harper/bbs/internal/models"
)

func TestCreateThread(t *testing.T) {
	db, err := InitDB(filepath.Join(t.TempDir(), "test.db"))
	if err != nil {
		t.Fatalf("InitDB failed: %v", err)
	}
	defer db.Close()

	// Create topic first
	topic := models.NewTopic("general", "General", "harper@cli")
	CreateTopic(db, topic)

	thread := models.NewThread(topic.ID, "Hello World", "harper@cli")
	err = CreateThread(db, thread)
	if err != nil {
		t.Fatalf("CreateThread failed: %v", err)
	}

	got, err := GetThreadByID(db, thread.ID.String())
	if err != nil {
		t.Fatalf("GetThreadByID failed: %v", err)
	}
	if got.Subject != "Hello World" {
		t.Errorf("expected subject 'Hello World', got '%s'", got.Subject)
	}
}

func TestListThreads(t *testing.T) {
	db, err := InitDB(filepath.Join(t.TempDir(), "test.db"))
	if err != nil {
		t.Fatalf("InitDB failed: %v", err)
	}
	defer db.Close()

	topic := models.NewTopic("general", "General", "harper@cli")
	CreateTopic(db, topic)

	thread1 := models.NewThread(topic.ID, "First", "harper@cli")
	thread2 := models.NewThread(topic.ID, "Second", "harper@cli")
	CreateThread(db, thread1)
	CreateThread(db, thread2)

	threads, err := ListThreads(db, topic.ID.String())
	if err != nil {
		t.Fatalf("ListThreads failed: %v", err)
	}
	if len(threads) != 2 {
		t.Errorf("expected 2 threads, got %d", len(threads))
	}
}

func TestStickyThread(t *testing.T) {
	db, err := InitDB(filepath.Join(t.TempDir(), "test.db"))
	if err != nil {
		t.Fatalf("InitDB failed: %v", err)
	}
	defer db.Close()

	topic := models.NewTopic("general", "General", "harper@cli")
	CreateTopic(db, topic)

	thread := models.NewThread(topic.ID, "Important", "harper@cli")
	CreateThread(db, thread)

	err = SetThreadSticky(db, thread.ID.String(), true)
	if err != nil {
		t.Fatalf("SetThreadSticky failed: %v", err)
	}

	got, _ := GetThreadByID(db, thread.ID.String())
	if !got.Sticky {
		t.Error("expected thread to be sticky")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/db/... -run TestCreateThread`
Expected: FAIL

**Step 3: Write threads.go**

```go
// ABOUTME: Thread database operations
// ABOUTME: CRUD functions for threads table

package db

import (
	"database/sql"
	"fmt"

	"github.com/harper/bbs/internal/models"
)

// CreateThread inserts a new thread into the database.
func CreateThread(db *sql.DB, thread *models.Thread) error {
	_, err := db.Exec(`
		INSERT INTO threads (id, topic_id, subject, created_at, created_by, sticky)
		VALUES (?, ?, ?, ?, ?, ?)`,
		thread.ID.String(), thread.TopicID.String(), thread.Subject,
		thread.CreatedAt, thread.CreatedBy, thread.Sticky)
	return err
}

// GetThreadByID retrieves a thread by its UUID (supports prefix matching).
func GetThreadByID(db *sql.DB, id string) (*models.Thread, error) {
	query := `SELECT id, topic_id, subject, created_at, created_by, sticky
			  FROM threads WHERE id = ? OR id LIKE ?`
	row := db.QueryRow(query, id, id+"%")
	return scanThread(row)
}

// ListThreads returns all threads in a topic, ordered by sticky then created_at.
func ListThreads(db *sql.DB, topicID string) ([]*models.Thread, error) {
	query := `SELECT id, topic_id, subject, created_at, created_by, sticky
			  FROM threads WHERE topic_id = ? OR topic_id LIKE ?
			  ORDER BY sticky DESC, created_at DESC`

	rows, err := db.Query(query, topicID, topicID+"%")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var threads []*models.Thread
	for rows.Next() {
		thread, err := scanThreadFromRows(rows)
		if err != nil {
			return nil, err
		}
		threads = append(threads, thread)
	}
	return threads, rows.Err()
}

// SetThreadSticky sets the sticky status of a thread.
func SetThreadSticky(db *sql.DB, id string, sticky bool) error {
	result, err := db.Exec(`UPDATE threads SET sticky = ? WHERE id = ? OR id LIKE ?`,
		sticky, id, id+"%")
	if err != nil {
		return err
	}
	rows, _ := result.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("thread not found: %s", id)
	}
	return nil
}

func scanThread(row *sql.Row) (*models.Thread, error) {
	var thread models.Thread
	var id, topicID string
	err := row.Scan(&id, &topicID, &thread.Subject,
		&thread.CreatedAt, &thread.CreatedBy, &thread.Sticky)
	if err != nil {
		return nil, err
	}
	thread.ID, _ = models.ParseUUID(id)
	thread.TopicID, _ = models.ParseUUID(topicID)
	return &thread, nil
}

func scanThreadFromRows(rows *sql.Rows) (*models.Thread, error) {
	var thread models.Thread
	var id, topicID string
	err := rows.Scan(&id, &topicID, &thread.Subject,
		&thread.CreatedAt, &thread.CreatedBy, &thread.Sticky)
	if err != nil {
		return nil, err
	}
	thread.ID, _ = models.ParseUUID(id)
	thread.TopicID, _ = models.ParseUUID(topicID)
	return &thread, nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/db/... -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/db/threads.go internal/db/threads_test.go
git commit -m "feat: add thread database operations"
```

---

## Task 3: Message Database Operations

**Files:**
- Create: `internal/db/messages.go`
- Create: `internal/db/messages_test.go`

**Step 1: Write failing test**

```go
// ABOUTME: Tests for message database operations
// ABOUTME: Verifies CRUD operations for messages

package db

import (
	"path/filepath"
	"testing"

	"github.com/harper/bbs/internal/models"
)

func TestCreateMessage(t *testing.T) {
	db, err := InitDB(filepath.Join(t.TempDir(), "test.db"))
	if err != nil {
		t.Fatalf("InitDB failed: %v", err)
	}
	defer db.Close()

	// Create topic and thread first
	topic := models.NewTopic("general", "General", "harper@cli")
	CreateTopic(db, topic)
	thread := models.NewThread(topic.ID, "Hello", "harper@cli")
	CreateThread(db, thread)

	msg := models.NewMessage(thread.ID, "Hello world!", "harper@cli")
	err = CreateMessage(db, msg)
	if err != nil {
		t.Fatalf("CreateMessage failed: %v", err)
	}

	got, err := GetMessageByID(db, msg.ID.String())
	if err != nil {
		t.Fatalf("GetMessageByID failed: %v", err)
	}
	if got.Content != "Hello world!" {
		t.Errorf("expected content 'Hello world!', got '%s'", got.Content)
	}
}

func TestListMessages(t *testing.T) {
	db, err := InitDB(filepath.Join(t.TempDir(), "test.db"))
	if err != nil {
		t.Fatalf("InitDB failed: %v", err)
	}
	defer db.Close()

	topic := models.NewTopic("general", "General", "harper@cli")
	CreateTopic(db, topic)
	thread := models.NewThread(topic.ID, "Hello", "harper@cli")
	CreateThread(db, thread)

	msg1 := models.NewMessage(thread.ID, "First", "harper@cli")
	msg2 := models.NewMessage(thread.ID, "Second", "claude@mcp")
	CreateMessage(db, msg1)
	CreateMessage(db, msg2)

	messages, err := ListMessages(db, thread.ID.String())
	if err != nil {
		t.Fatalf("ListMessages failed: %v", err)
	}
	if len(messages) != 2 {
		t.Errorf("expected 2 messages, got %d", len(messages))
	}
}

func TestUpdateMessage(t *testing.T) {
	db, err := InitDB(filepath.Join(t.TempDir(), "test.db"))
	if err != nil {
		t.Fatalf("InitDB failed: %v", err)
	}
	defer db.Close()

	topic := models.NewTopic("general", "General", "harper@cli")
	CreateTopic(db, topic)
	thread := models.NewThread(topic.ID, "Hello", "harper@cli")
	CreateThread(db, thread)

	msg := models.NewMessage(thread.ID, "Original", "harper@cli")
	CreateMessage(db, msg)

	err = UpdateMessage(db, msg.ID.String(), "Edited content")
	if err != nil {
		t.Fatalf("UpdateMessage failed: %v", err)
	}

	got, _ := GetMessageByID(db, msg.ID.String())
	if got.Content != "Edited content" {
		t.Errorf("expected 'Edited content', got '%s'", got.Content)
	}
	if got.EditedAt == nil {
		t.Error("expected EditedAt to be set")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/db/... -run TestCreateMessage`
Expected: FAIL

**Step 3: Write messages.go**

```go
// ABOUTME: Message database operations
// ABOUTME: CRUD functions for messages table

package db

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/harper/bbs/internal/models"
)

// CreateMessage inserts a new message into the database.
func CreateMessage(db *sql.DB, msg *models.Message) error {
	_, err := db.Exec(`
		INSERT INTO messages (id, thread_id, content, created_at, created_by, edited_at)
		VALUES (?, ?, ?, ?, ?, ?)`,
		msg.ID.String(), msg.ThreadID.String(), msg.Content,
		msg.CreatedAt, msg.CreatedBy, msg.EditedAt)
	return err
}

// GetMessageByID retrieves a message by its UUID (supports prefix matching).
func GetMessageByID(db *sql.DB, id string) (*models.Message, error) {
	query := `SELECT id, thread_id, content, created_at, created_by, edited_at
			  FROM messages WHERE id = ? OR id LIKE ?`
	row := db.QueryRow(query, id, id+"%")
	return scanMessage(row)
}

// ListMessages returns all messages in a thread, ordered by created_at.
func ListMessages(db *sql.DB, threadID string) ([]*models.Message, error) {
	query := `SELECT id, thread_id, content, created_at, created_by, edited_at
			  FROM messages WHERE thread_id = ? OR thread_id LIKE ?
			  ORDER BY created_at ASC`

	rows, err := db.Query(query, threadID, threadID+"%")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var messages []*models.Message
	for rows.Next() {
		msg, err := scanMessageFromRows(rows)
		if err != nil {
			return nil, err
		}
		messages = append(messages, msg)
	}
	return messages, rows.Err()
}

// UpdateMessage updates the content of a message and sets edited_at.
func UpdateMessage(db *sql.DB, id string, content string) error {
	now := time.Now()
	result, err := db.Exec(`UPDATE messages SET content = ?, edited_at = ? WHERE id = ? OR id LIKE ?`,
		content, now, id, id+"%")
	if err != nil {
		return err
	}
	rows, _ := result.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("message not found: %s", id)
	}
	return nil
}

func scanMessage(row *sql.Row) (*models.Message, error) {
	var msg models.Message
	var id, threadID string
	var editedAt sql.NullTime
	err := row.Scan(&id, &threadID, &msg.Content,
		&msg.CreatedAt, &msg.CreatedBy, &editedAt)
	if err != nil {
		return nil, err
	}
	msg.ID, _ = models.ParseUUID(id)
	msg.ThreadID, _ = models.ParseUUID(threadID)
	if editedAt.Valid {
		msg.EditedAt = &editedAt.Time
	}
	return &msg, nil
}

func scanMessageFromRows(rows *sql.Rows) (*models.Message, error) {
	var msg models.Message
	var id, threadID string
	var editedAt sql.NullTime
	err := rows.Scan(&id, &threadID, &msg.Content,
		&msg.CreatedAt, &msg.CreatedBy, &editedAt)
	if err != nil {
		return nil, err
	}
	msg.ID, _ = models.ParseUUID(id)
	msg.ThreadID, _ = models.ParseUUID(threadID)
	if editedAt.Valid {
		msg.EditedAt = &editedAt.Time
	}
	return &msg, nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/db/... -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/db/messages.go internal/db/messages_test.go
git commit -m "feat: add message database operations"
```

---

## Task 4: Topic CLI Commands

**Files:**
- Create: `cmd/bbs/topic.go`

**Step 1: Create topic.go**

```go
// ABOUTME: Topic CLI commands
// ABOUTME: Implements topic list, new, archive, show subcommands

package main

import (
	"fmt"
	"os"
	"text/tabwriter"

	"github.com/fatih/color"
	"github.com/harper/bbs/internal/db"
	"github.com/harper/bbs/internal/identity"
	"github.com/harper/bbs/internal/models"
	"github.com/spf13/cobra"
)

var topicCmd = &cobra.Command{
	Use:   "topic",
	Short: "Manage topics",
	Long:  "Create, list, archive, and view topics on the board.",
}

var topicListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all topics",
	RunE:  runTopicList,
}

var topicNewCmd = &cobra.Command{
	Use:   "new <name> [description]",
	Short: "Create a new topic",
	Args:  cobra.RangeArgs(1, 2),
	RunE:  runTopicNew,
}

var topicArchiveCmd = &cobra.Command{
	Use:   "archive <topic>",
	Short: "Archive a topic",
	Args:  cobra.ExactArgs(1),
	RunE:  runTopicArchive,
}

var topicShowCmd = &cobra.Command{
	Use:   "show <topic>",
	Short: "Show topic details",
	Args:  cobra.ExactArgs(1),
	RunE:  runTopicShow,
}

var (
	showArchived bool
	unarchive    bool
)

func init() {
	rootCmd.AddCommand(topicCmd)
	topicCmd.AddCommand(topicListCmd, topicNewCmd, topicArchiveCmd, topicShowCmd)

	topicListCmd.Flags().BoolVar(&showArchived, "archived", false, "show archived topics")
	topicArchiveCmd.Flags().BoolVar(&unarchive, "unarchive", false, "unarchive instead of archive")
}

func runTopicList(cmd *cobra.Command, args []string) error {
	topics, err := db.ListTopics(dbConn, showArchived)
	if err != nil {
		return err
	}

	if len(topics) == 0 {
		fmt.Println("No topics found.")
		return nil
	}

	w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
	fmt.Fprintln(w, "NAME\tDESCRIPTION\tCREATED BY")
	for _, t := range topics {
		fmt.Fprintf(w, "%s\t%s\t%s\n", t.Name, t.Description, t.CreatedBy)
	}
	return w.Flush()
}

func runTopicNew(cmd *cobra.Command, args []string) error {
	name := args[0]
	description := ""
	if len(args) > 1 {
		description = args[1]
	}

	id := identity.GetIdentity(identity, "cli")
	topic := models.NewTopic(name, description, id)

	if err := db.CreateTopic(dbConn, topic); err != nil {
		return fmt.Errorf("failed to create topic: %w", err)
	}

	color.Green("Created topic: %s", name)
	fmt.Printf("ID: %s\n", topic.ID.String()[:8])
	return nil
}

func runTopicArchive(cmd *cobra.Command, args []string) error {
	topicID, err := db.ResolveTopicID(dbConn, args[0])
	if err != nil {
		return err
	}

	archived := !unarchive
	if err := db.ArchiveTopic(dbConn, topicID, archived); err != nil {
		return err
	}

	if archived {
		color.Yellow("Archived topic: %s", args[0])
	} else {
		color.Green("Unarchived topic: %s", args[0])
	}
	return nil
}

func runTopicShow(cmd *cobra.Command, args []string) error {
	topic, err := db.GetTopicByName(dbConn, args[0])
	if err != nil {
		topic, err = db.GetTopicByID(dbConn, args[0])
		if err != nil {
			return fmt.Errorf("topic not found: %s", args[0])
		}
	}

	fmt.Printf("Topic: %s\n", topic.Name)
	fmt.Printf("Description: %s\n", topic.Description)
	fmt.Printf("Created by: %s\n", topic.CreatedBy)
	fmt.Printf("Created at: %s\n", topic.CreatedAt.Format("2006-01-02 15:04"))
	if topic.Archived {
		color.Yellow("Status: Archived")
	}

	// Show recent threads
	threads, _ := db.ListThreads(dbConn, topic.ID.String())
	if len(threads) > 0 {
		fmt.Printf("\nRecent threads (%d):\n", len(threads))
		for i, t := range threads {
			if i >= 5 {
				fmt.Printf("  ... and %d more\n", len(threads)-5)
				break
			}
			prefix := "  "
			if t.Sticky {
				prefix = "ðŸ“Œ"
			}
			fmt.Printf("%s %s (%s)\n", prefix, t.Subject, t.CreatedBy)
		}
	}

	return nil
}
```

**Step 2: Add fatih/color dependency**

Run: `go get github.com/fatih/color`

**Step 3: Fix identity variable conflict**

The `identity` variable conflicts with the package name. Update the function to use the global flag directly:

```go
// In runTopicNew, change:
id := identity.GetIdentity(identityFlag, "cli")
```

And update root.go to rename the variable from `identity` to `identityFlag`.

**Step 4: Build and verify**

Run: `go build ./cmd/bbs && ./bbs topic --help`
Expected: Shows topic subcommands

**Step 5: Commit**

```bash
git add cmd/bbs/topic.go cmd/bbs/root.go go.mod go.sum
git commit -m "feat: add topic CLI commands"
```

---

## Task 5: Thread CLI Commands

**Files:**
- Create: `cmd/bbs/thread.go`

**Step 1: Create thread.go**

```go
// ABOUTME: Thread CLI commands
// ABOUTME: Implements thread list, new, show, sticky subcommands

package main

import (
	"fmt"
	"os"
	"text/tabwriter"

	"github.com/fatih/color"
	"github.com/harper/bbs/internal/db"
	"github.com/harper/bbs/internal/identity"
	"github.com/harper/bbs/internal/models"
	"github.com/spf13/cobra"
)

var threadCmd = &cobra.Command{
	Use:   "thread",
	Short: "Manage threads",
	Long:  "Create, list, and view threads within topics.",
}

var threadListCmd = &cobra.Command{
	Use:   "list <topic>",
	Short: "List threads in a topic",
	Args:  cobra.ExactArgs(1),
	RunE:  runThreadList,
}

var threadNewCmd = &cobra.Command{
	Use:   "new <topic> <subject>",
	Short: "Create a new thread",
	Args:  cobra.ExactArgs(2),
	RunE:  runThreadNew,
}

var threadShowCmd = &cobra.Command{
	Use:   "show <thread>",
	Short: "Show thread with messages",
	Args:  cobra.ExactArgs(1),
	RunE:  runThreadShow,
}

var threadStickyCmd = &cobra.Command{
	Use:   "sticky <thread>",
	Short: "Pin/unpin a thread",
	Args:  cobra.ExactArgs(1),
	RunE:  runThreadSticky,
}

var unsticky bool

func init() {
	rootCmd.AddCommand(threadCmd)
	threadCmd.AddCommand(threadListCmd, threadNewCmd, threadShowCmd, threadStickyCmd)

	threadStickyCmd.Flags().BoolVar(&unsticky, "unpin", false, "unpin instead of pin")
}

func runThreadList(cmd *cobra.Command, args []string) error {
	topicID, err := db.ResolveTopicID(dbConn, args[0])
	if err != nil {
		return err
	}

	threads, err := db.ListThreads(dbConn, topicID)
	if err != nil {
		return err
	}

	if len(threads) == 0 {
		fmt.Println("No threads found.")
		return nil
	}

	w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
	fmt.Fprintln(w, "SUBJECT\tCREATED BY\tDATE")
	for _, t := range threads {
		prefix := ""
		if t.Sticky {
			prefix = "ðŸ“Œ "
		}
		fmt.Fprintf(w, "%s%s\t%s\t%s\n", prefix, t.Subject, t.CreatedBy, t.CreatedAt.Format("Jan 02"))
	}
	return w.Flush()
}

func runThreadNew(cmd *cobra.Command, args []string) error {
	topicID, err := db.ResolveTopicID(dbConn, args[0])
	if err != nil {
		return err
	}

	topicUUID, _ := models.ParseUUID(topicID)
	id := identity.GetIdentity(identityFlag, "cli")
	thread := models.NewThread(topicUUID, args[1], id)

	if err := db.CreateThread(dbConn, thread); err != nil {
		return fmt.Errorf("failed to create thread: %w", err)
	}

	color.Green("Created thread: %s", args[1])
	fmt.Printf("ID: %s\n", thread.ID.String()[:8])
	return nil
}

func runThreadShow(cmd *cobra.Command, args []string) error {
	thread, err := db.GetThreadByID(dbConn, args[0])
	if err != nil {
		return fmt.Errorf("thread not found: %s", args[0])
	}

	if thread.Sticky {
		fmt.Print("ðŸ“Œ ")
	}
	fmt.Printf("%s\n", thread.Subject)
	faint := color.New(color.Faint)
	faint.Printf("by %s on %s\n\n", thread.CreatedBy, thread.CreatedAt.Format("2006-01-02 15:04"))

	messages, err := db.ListMessages(dbConn, thread.ID.String())
	if err != nil {
		return err
	}

	for _, msg := range messages {
		fmt.Printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")
		faint.Printf("%s Â· %s", msg.CreatedBy, msg.CreatedAt.Format("Jan 02 15:04"))
		if msg.EditedAt != nil {
			faint.Printf(" (edited)")
		}
		fmt.Println()
		fmt.Println(msg.Content)
		fmt.Println()
	}

	if len(messages) == 0 {
		fmt.Println("No messages yet.")
	}

	return nil
}

func runThreadSticky(cmd *cobra.Command, args []string) error {
	sticky := !unsticky
	if err := db.SetThreadSticky(dbConn, args[0], sticky); err != nil {
		return err
	}

	if sticky {
		color.Green("ðŸ“Œ Pinned thread")
	} else {
		color.Yellow("Unpinned thread")
	}
	return nil
}
```

**Step 2: Build and verify**

Run: `go build ./cmd/bbs && ./bbs thread --help`
Expected: Shows thread subcommands

**Step 3: Commit**

```bash
git add cmd/bbs/thread.go
git commit -m "feat: add thread CLI commands"
```

---

## Task 6: Post CLI Command

**Files:**
- Create: `cmd/bbs/post.go`

**Step 1: Create post.go**

```go
// ABOUTME: Post CLI command
// ABOUTME: Implements posting messages to threads

package main

import (
	"fmt"

	"github.com/fatih/color"
	"github.com/harper/bbs/internal/db"
	"github.com/harper/bbs/internal/identity"
	"github.com/harper/bbs/internal/models"
	"github.com/spf13/cobra"
)

var postCmd = &cobra.Command{
	Use:   "post <thread> <message>",
	Short: "Post a message to a thread",
	Args:  cobra.ExactArgs(2),
	RunE:  runPost,
}

var editCmd = &cobra.Command{
	Use:   "edit <message-id> <new-content>",
	Short: "Edit a message",
	Args:  cobra.ExactArgs(2),
	RunE:  runEdit,
}

func init() {
	rootCmd.AddCommand(postCmd)
	rootCmd.AddCommand(editCmd)
}

func runPost(cmd *cobra.Command, args []string) error {
	thread, err := db.GetThreadByID(dbConn, args[0])
	if err != nil {
		return fmt.Errorf("thread not found: %s", args[0])
	}

	id := identity.GetIdentity(identityFlag, "cli")
	msg := models.NewMessage(thread.ID, args[1], id)

	if err := db.CreateMessage(dbConn, msg); err != nil {
		return fmt.Errorf("failed to post message: %w", err)
	}

	color.Green("Posted to: %s", thread.Subject)
	fmt.Printf("Message ID: %s\n", msg.ID.String()[:8])
	return nil
}

func runEdit(cmd *cobra.Command, args []string) error {
	if err := db.UpdateMessage(dbConn, args[0], args[1]); err != nil {
		return err
	}

	color.Green("Message updated")
	return nil
}
```

**Step 2: Build and verify**

Run: `go build ./cmd/bbs && ./bbs post --help`
Expected: Shows post help

**Step 3: Commit**

```bash
git add cmd/bbs/post.go
git commit -m "feat: add post and edit CLI commands"
```

---

## Phase 2 Complete Checklist

After completing all tasks:

- [ ] `go build ./cmd/bbs` succeeds
- [ ] `go test ./...` passes
- [ ] `bbs topic list` works
- [ ] `bbs topic new general "General discussion"` creates topic
- [ ] `bbs thread new general "Hello"` creates thread
- [ ] `bbs post <thread-id> "Hello world"` posts message
- [ ] `bbs thread show <thread-id>` shows messages

---

## Next Phase

Phase 3 will add:
- MCP server with tools and resources
- Whoami command
