# Phase 3: MCP Server - Implementation Plan

> **For Claude:** Implement this plan task-by-task with TDD.

**Goal:** Add MCP server so agents can interact with the BBS.

**Architecture:** MCP server with tools, resources, and prompts following toki patterns.

**Tech Stack:** modelcontextprotocol/go-sdk

---

## Task 1: MCP Server Skeleton

**Files:**
- Create: `internal/mcp/server.go`

**Implementation:**

```go
// ABOUTME: MCP server initialization and configuration
// ABOUTME: Sets up server with tools, resources, and prompts

package mcp

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// Server wraps MCP server with database connection.
type Server struct {
	mcp *mcp.Server
	db  *sql.DB
}

// NewServer creates MCP server with all capabilities.
func NewServer(db *sql.DB) (*Server, error) {
	if db == nil {
		return nil, fmt.Errorf("database connection is required")
	}

	mcpServer := mcp.NewServer(
		&mcp.Implementation{
			Name:    "bbs",
			Version: "1.0.0",
		},
		nil,
	)

	s := &Server{
		mcp: mcpServer,
		db:  db,
	}

	s.registerTools()
	s.registerResources()
	s.registerPrompts()

	return s, nil
}

// Serve starts the MCP server in stdio mode.
func (s *Server) Serve(ctx context.Context) error {
	return s.mcp.Run(ctx, &mcp.StdioTransport{})
}
```

**Step 2: Add MCP dependency**

Run: `go get github.com/modelcontextprotocol/go-sdk`

**Step 3: Create placeholder files for tools/resources/prompts**

Create `internal/mcp/tools.go`:
```go
// ABOUTME: MCP tool implementations
// ABOUTME: CRUD operations exposed as MCP tools

package mcp

func (s *Server) registerTools() {
	// Tools will be added here
}
```

Create `internal/mcp/resources.go`:
```go
// ABOUTME: MCP resource implementations
// ABOUTME: Read-only data access via MCP resources

package mcp

func (s *Server) registerResources() {
	// Resources will be added here
}
```

Create `internal/mcp/prompts.go`:
```go
// ABOUTME: MCP prompt templates
// ABOUTME: Guided workflows for common tasks

package mcp

func (s *Server) registerPrompts() {
	// Prompts will be added here
}
```

**Step 4: Verify it compiles**

Run: `go build ./...`

**Step 5: Commit**

```bash
git add internal/mcp/
git commit -m "feat: add MCP server skeleton"
```

---

## Task 2: MCP Command

**Files:**
- Create: `cmd/bbs/mcp.go`

**Implementation:**

```go
// ABOUTME: MCP server command implementation
// ABOUTME: Starts BBS MCP server in stdio mode

package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"github.com/harper/bbs/internal/mcp"
	"github.com/spf13/cobra"
)

var mcpCmd = &cobra.Command{
	Use:   "mcp",
	Short: "Start MCP server (stdio mode)",
	Long: `Start the Model Context Protocol server for AI agent integration.

The MCP server communicates via stdio, allowing AI agents like Claude
to interact with BBS through a standardized protocol.`,
	RunE: runMCP,
}

func init() {
	rootCmd.AddCommand(mcpCmd)
}

func runMCP(cmd *cobra.Command, args []string) error {
	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer cancel()

	if dbConn == nil {
		return fmt.Errorf("database connection not initialized")
	}

	server, err := mcp.NewServer(dbConn)
	if err != nil {
		return err
	}

	return server.Serve(ctx)
}
```

**Step 2: Build and verify**

Run: `go build ./cmd/bbs && ./bbs mcp --help`

**Step 3: Commit**

```bash
git add cmd/bbs/mcp.go
git commit -m "feat: add mcp command"
```

---

## Task 3: MCP Tools

**Files:**
- Update: `internal/mcp/tools.go`

**Implementation:**

```go
// ABOUTME: MCP tool implementations
// ABOUTME: CRUD operations exposed as MCP tools

package mcp

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/harper/bbs/internal/db"
	"github.com/harper/bbs/internal/identity"
	"github.com/harper/bbs/internal/models"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

func (s *Server) registerTools() {
	// Topic tools
	s.mcp.AddTool(&mcp.Tool{
		Name:        "list_topics",
		Description: "List all topics on the board",
		InputSchema: json.RawMessage(`{"type":"object","properties":{"include_archived":{"type":"boolean","description":"Include archived topics"}}}`),
	}, s.handleListTopics)

	s.mcp.AddTool(&mcp.Tool{
		Name:        "create_topic",
		Description: "Create a new topic",
		InputSchema: json.RawMessage(`{"type":"object","properties":{"name":{"type":"string"},"description":{"type":"string"}},"required":["name"]}`),
	}, s.handleCreateTopic)

	s.mcp.AddTool(&mcp.Tool{
		Name:        "archive_topic",
		Description: "Archive or unarchive a topic",
		InputSchema: json.RawMessage(`{"type":"object","properties":{"topic":{"type":"string"},"archived":{"type":"boolean"}},"required":["topic","archived"]}`),
	}, s.handleArchiveTopic)

	// Thread tools
	s.mcp.AddTool(&mcp.Tool{
		Name:        "list_threads",
		Description: "List threads in a topic",
		InputSchema: json.RawMessage(`{"type":"object","properties":{"topic":{"type":"string"}},"required":["topic"]}`),
	}, s.handleListThreads)

	s.mcp.AddTool(&mcp.Tool{
		Name:        "create_thread",
		Description: "Create a new thread with initial message",
		InputSchema: json.RawMessage(`{"type":"object","properties":{"topic":{"type":"string"},"subject":{"type":"string"},"message":{"type":"string"},"agent_name":{"type":"string"}},"required":["topic","subject"]}`),
	}, s.handleCreateThread)

	s.mcp.AddTool(&mcp.Tool{
		Name:        "sticky_thread",
		Description: "Pin or unpin a thread",
		InputSchema: json.RawMessage(`{"type":"object","properties":{"thread":{"type":"string"},"sticky":{"type":"boolean"}},"required":["thread","sticky"]}`),
	}, s.handleStickyThread)

	// Message tools
	s.mcp.AddTool(&mcp.Tool{
		Name:        "list_messages",
		Description: "List messages in a thread",
		InputSchema: json.RawMessage(`{"type":"object","properties":{"thread":{"type":"string"}},"required":["thread"]}`),
	}, s.handleListMessages)

	s.mcp.AddTool(&mcp.Tool{
		Name:        "post_message",
		Description: "Post a message to a thread",
		InputSchema: json.RawMessage(`{"type":"object","properties":{"thread":{"type":"string"},"content":{"type":"string"},"agent_name":{"type":"string"}},"required":["thread","content"]}`),
	}, s.handlePostMessage)

	s.mcp.AddTool(&mcp.Tool{
		Name:        "edit_message",
		Description: "Edit an existing message",
		InputSchema: json.RawMessage(`{"type":"object","properties":{"message_id":{"type":"string"},"content":{"type":"string"}},"required":["message_id","content"]}`),
	}, s.handleEditMessage)
}

func (s *Server) handleListTopics(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var args struct {
		IncludeArchived bool `json:"include_archived"`
	}
	json.Unmarshal(req.Params.Arguments, &args)

	topics, err := db.ListTopics(s.db, args.IncludeArchived)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	result, _ := json.Marshal(topics)
	return mcp.NewToolResultText(string(result)), nil
}

func (s *Server) handleCreateTopic(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var args struct {
		Name        string `json:"name"`
		Description string `json:"description"`
		AgentName   string `json:"agent_name"`
	}
	json.Unmarshal(req.Params.Arguments, &args)

	id := identity.GetIdentity(args.AgentName, "mcp")
	topic := models.NewTopic(args.Name, args.Description, id)

	if err := db.CreateTopic(s.db, topic); err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	return mcp.NewToolResultText(fmt.Sprintf("Created topic: %s (ID: %s)", args.Name, topic.ID.String()[:8])), nil
}

func (s *Server) handleArchiveTopic(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var args struct {
		Topic    string `json:"topic"`
		Archived bool   `json:"archived"`
	}
	json.Unmarshal(req.Params.Arguments, &args)

	topicID, err := db.ResolveTopicID(s.db, args.Topic)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	if err := db.ArchiveTopic(s.db, topicID, args.Archived); err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	status := "archived"
	if !args.Archived {
		status = "unarchived"
	}
	return mcp.NewToolResultText(fmt.Sprintf("Topic %s", status)), nil
}

func (s *Server) handleListThreads(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var args struct {
		Topic string `json:"topic"`
	}
	json.Unmarshal(req.Params.Arguments, &args)

	topicID, err := db.ResolveTopicID(s.db, args.Topic)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	threads, err := db.ListThreads(s.db, topicID)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	result, _ := json.Marshal(threads)
	return mcp.NewToolResultText(string(result)), nil
}

func (s *Server) handleCreateThread(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var args struct {
		Topic     string `json:"topic"`
		Subject   string `json:"subject"`
		Message   string `json:"message"`
		AgentName string `json:"agent_name"`
	}
	json.Unmarshal(req.Params.Arguments, &args)

	topicID, err := db.ResolveTopicID(s.db, args.Topic)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	topicUUID, _ := models.ParseUUID(topicID)
	id := identity.GetIdentity(args.AgentName, "mcp")
	thread := models.NewThread(topicUUID, args.Subject, id)

	if err := db.CreateThread(s.db, thread); err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	// Post initial message if provided
	if args.Message != "" {
		msg := models.NewMessage(thread.ID, args.Message, id)
		db.CreateMessage(s.db, msg)
	}

	return mcp.NewToolResultText(fmt.Sprintf("Created thread: %s (ID: %s)", args.Subject, thread.ID.String()[:8])), nil
}

func (s *Server) handleStickyThread(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var args struct {
		Thread string `json:"thread"`
		Sticky bool   `json:"sticky"`
	}
	json.Unmarshal(req.Params.Arguments, &args)

	if err := db.SetThreadSticky(s.db, args.Thread, args.Sticky); err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	status := "pinned"
	if !args.Sticky {
		status = "unpinned"
	}
	return mcp.NewToolResultText(fmt.Sprintf("Thread %s", status)), nil
}

func (s *Server) handleListMessages(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var args struct {
		Thread string `json:"thread"`
	}
	json.Unmarshal(req.Params.Arguments, &args)

	messages, err := db.ListMessages(s.db, args.Thread)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	result, _ := json.Marshal(messages)
	return mcp.NewToolResultText(string(result)), nil
}

func (s *Server) handlePostMessage(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var args struct {
		Thread    string `json:"thread"`
		Content   string `json:"content"`
		AgentName string `json:"agent_name"`
	}
	json.Unmarshal(req.Params.Arguments, &args)

	thread, err := db.GetThreadByID(s.db, args.Thread)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	id := identity.GetIdentity(args.AgentName, "mcp")
	msg := models.NewMessage(thread.ID, args.Content, id)

	if err := db.CreateMessage(s.db, msg); err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	return mcp.NewToolResultText(fmt.Sprintf("Posted message (ID: %s)", msg.ID.String()[:8])), nil
}

func (s *Server) handleEditMessage(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var args struct {
		MessageID string `json:"message_id"`
		Content   string `json:"content"`
	}
	json.Unmarshal(req.Params.Arguments, &args)

	if err := db.UpdateMessage(s.db, args.MessageID, args.Content); err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	return mcp.NewToolResultText("Message updated"), nil
}
```

**Step 2: Verify it compiles**

Run: `go build ./...`

**Step 3: Commit**

```bash
git add internal/mcp/tools.go
git commit -m "feat: add MCP tools for topics, threads, messages"
```

---

## Task 4: MCP Resources

**Files:**
- Update: `internal/mcp/resources.go`

**Implementation:**

```go
// ABOUTME: MCP resource implementations
// ABOUTME: Read-only data access via MCP resources

package mcp

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/harper/bbs/internal/db"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

func (s *Server) registerResources() {
	s.mcp.AddResource(&mcp.Resource{
		URI:         "bbs://topics",
		Name:        "All Topics",
		Description: "List of all active topics",
		MimeType:    "application/json",
	}, s.handleTopicsResource)

	s.mcp.AddResource(&mcp.Resource{
		URI:         "bbs://recent",
		Name:        "Recent Activity",
		Description: "Recent threads and messages across all topics",
		MimeType:    "text/markdown",
	}, s.handleRecentResource)

	// Dynamic resources for threads and messages
	s.mcp.AddResourceTemplate(&mcp.ResourceTemplate{
		URITemplate: "bbs://topics/{topic}/threads",
		Name:        "Topic Threads",
		Description: "Threads in a specific topic",
		MimeType:    "application/json",
	}, s.handleTopicThreadsResource)

	s.mcp.AddResourceTemplate(&mcp.ResourceTemplate{
		URITemplate: "bbs://threads/{thread}/messages",
		Name:        "Thread Messages",
		Description: "Messages in a specific thread",
		MimeType:    "text/markdown",
	}, s.handleThreadMessagesResource)
}

func (s *Server) handleTopicsResource(ctx context.Context, req *mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
	topics, err := db.ListTopics(s.db, false)
	if err != nil {
		return nil, err
	}

	data, _ := json.MarshalIndent(topics, "", "  ")
	return &mcp.ReadResourceResult{
		Contents: []mcp.ResourceContents{{
			URI:      "bbs://topics",
			MimeType: "application/json",
			Text:     string(data),
		}},
	}, nil
}

func (s *Server) handleRecentResource(ctx context.Context, req *mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
	topics, _ := db.ListTopics(s.db, false)

	var sb strings.Builder
	sb.WriteString("# Recent Activity\n\n")

	for _, topic := range topics {
		threads, _ := db.ListThreads(s.db, topic.ID.String())
		if len(threads) == 0 {
			continue
		}

		sb.WriteString(fmt.Sprintf("## %s\n\n", topic.Name))
		for i, thread := range threads {
			if i >= 3 {
				break
			}
			prefix := ""
			if thread.Sticky {
				prefix = "ðŸ“Œ "
			}
			sb.WriteString(fmt.Sprintf("- %s**%s** by %s\n", prefix, thread.Subject, thread.CreatedBy))
		}
		sb.WriteString("\n")
	}

	return &mcp.ReadResourceResult{
		Contents: []mcp.ResourceContents{{
			URI:      "bbs://recent",
			MimeType: "text/markdown",
			Text:     sb.String(),
		}},
	}, nil
}

func (s *Server) handleTopicThreadsResource(ctx context.Context, req *mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
	// Extract topic from URI
	parts := strings.Split(req.Params.URI, "/")
	if len(parts) < 4 {
		return nil, fmt.Errorf("invalid URI")
	}
	topicName := parts[3]

	topicID, err := db.ResolveTopicID(s.db, topicName)
	if err != nil {
		return nil, err
	}

	threads, err := db.ListThreads(s.db, topicID)
	if err != nil {
		return nil, err
	}

	data, _ := json.MarshalIndent(threads, "", "  ")
	return &mcp.ReadResourceResult{
		Contents: []mcp.ResourceContents{{
			URI:      req.Params.URI,
			MimeType: "application/json",
			Text:     string(data),
		}},
	}, nil
}

func (s *Server) handleThreadMessagesResource(ctx context.Context, req *mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
	// Extract thread from URI
	parts := strings.Split(req.Params.URI, "/")
	if len(parts) < 4 {
		return nil, fmt.Errorf("invalid URI")
	}
	threadID := parts[3]

	thread, err := db.GetThreadByID(s.db, threadID)
	if err != nil {
		return nil, err
	}

	messages, err := db.ListMessages(s.db, thread.ID.String())
	if err != nil {
		return nil, err
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# %s\n\n", thread.Subject))
	sb.WriteString(fmt.Sprintf("*Started by %s on %s*\n\n", thread.CreatedBy, thread.CreatedAt.Format("2006-01-02")))
	sb.WriteString("---\n\n")

	for _, msg := range messages {
		sb.WriteString(fmt.Sprintf("**%s** Â· %s\n\n", msg.CreatedBy, msg.CreatedAt.Format("Jan 02 15:04")))
		sb.WriteString(msg.Content)
		sb.WriteString("\n\n---\n\n")
	}

	return &mcp.ReadResourceResult{
		Contents: []mcp.ResourceContents{{
			URI:      req.Params.URI,
			MimeType: "text/markdown",
			Text:     sb.String(),
		}},
	}, nil
}
```

**Step 2: Verify it compiles**

Run: `go build ./...`

**Step 3: Commit**

```bash
git add internal/mcp/resources.go
git commit -m "feat: add MCP resources for topics, threads, messages"
```

---

## Task 5: MCP Prompts

**Files:**
- Update: `internal/mcp/prompts.go`

**Implementation:**

```go
// ABOUTME: MCP prompt templates
// ABOUTME: Guided workflows for common tasks

package mcp

import (
	"context"
	"fmt"

	"github.com/modelcontextprotocol/go-sdk/mcp"
)

func (s *Server) registerPrompts() {
	s.mcp.AddPrompt(&mcp.Prompt{
		Name:        "post-update",
		Description: "Post a status update to a topic",
		Arguments: []mcp.PromptArgument{
			{Name: "topic", Description: "Topic to post to", Required: true},
			{Name: "subject", Description: "Thread subject", Required: true},
		},
	}, s.handlePostUpdatePrompt)

	s.mcp.AddPrompt(&mcp.Prompt{
		Name:        "summarize-thread",
		Description: "Summarize a thread discussion",
		Arguments: []mcp.PromptArgument{
			{Name: "thread", Description: "Thread ID to summarize", Required: true},
		},
	}, s.handleSummarizePrompt)
}

func (s *Server) handlePostUpdatePrompt(ctx context.Context, req *mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
	topic := req.Params.Arguments["topic"]
	subject := req.Params.Arguments["subject"]

	return &mcp.GetPromptResult{
		Description: fmt.Sprintf("Post update to %s: %s", topic, subject),
		Messages: []mcp.PromptMessage{
			{
				Role: "user",
				Content: mcp.TextContent{
					Type: "text",
					Text: fmt.Sprintf(`Post a status update to the BBS.

Topic: %s
Subject: %s

Please use the create_thread tool with your update message. Keep it concise and informative.`, topic, subject),
				},
			},
		},
	}, nil
}

func (s *Server) handleSummarizePrompt(ctx context.Context, req *mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
	threadID := req.Params.Arguments["thread"]

	return &mcp.GetPromptResult{
		Description: fmt.Sprintf("Summarize thread %s", threadID),
		Messages: []mcp.PromptMessage{
			{
				Role: "user",
				Content: mcp.TextContent{
					Type: "text",
					Text: fmt.Sprintf(`Please summarize the discussion in thread %s.

First, use the list_messages tool to read the thread, then provide a concise summary of:
1. The main topic/question
2. Key points discussed
3. Any conclusions or action items`, threadID),
				},
			},
		},
	}, nil
}
```

**Step 2: Verify it compiles**

Run: `go build ./...`

**Step 3: Commit**

```bash
git add internal/mcp/prompts.go
git commit -m "feat: add MCP prompts for common workflows"
```

---

## Phase 3 Complete Checklist

- [ ] `go build ./cmd/bbs` succeeds
- [ ] `./bbs mcp --help` shows help
- [ ] MCP server starts without errors
