# Phase 5: Vault Sync - Implementation Plan

> **For Claude:** Implement this plan task-by-task.

**Goal:** Add vault sync for cross-device synchronization.

**Architecture:** Uses suitesync/vault package like position does.

**Tech Stack:** github.com/harperreed/sweet/suitesync/vault

---

## Task 1: Sync Config

**Files:**
- Create: `internal/config/config.go`

**Step 1: Add dependency**

Run: `go get github.com/harperreed/sweet/suitesync/vault`

**Step 2: Create config.go**

```go
// ABOUTME: Sync configuration management
// ABOUTME: Handles server, auth, and encryption settings

package config

import (
	"encoding/json"
	"os"
	"path/filepath"
)

// Config stores sync configuration
type Config struct {
	Server       string `json:"server"`
	UserID       string `json:"user_id"`
	Token        string `json:"token"`
	RefreshToken string `json:"refresh_token"`
	TokenExpires string `json:"token_expires"`
	DerivedKey   string `json:"derived_key"`
	DeviceID     string `json:"device_id"`
	VaultDB      string `json:"vault_db"`
	AutoSync     bool   `json:"auto_sync"`
}

// GetConfigPath returns the config file path
func GetConfigPath() string {
	homeDir, _ := os.UserHomeDir()
	configDir := os.Getenv("XDG_CONFIG_HOME")
	if configDir == "" {
		configDir = filepath.Join(homeDir, ".config")
	}
	return filepath.Join(configDir, "bbs", "sync.json")
}

// GetVaultDBPath returns the vault database path
func GetVaultDBPath() string {
	homeDir, _ := os.UserHomeDir()
	configDir := os.Getenv("XDG_CONFIG_HOME")
	if configDir == "" {
		configDir = filepath.Join(homeDir, ".config")
	}
	return filepath.Join(configDir, "bbs", "vault.db")
}

// Load reads config from disk
func Load() (*Config, error) {
	path := GetConfigPath()
	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return &Config{AutoSync: true}, nil
		}
		return nil, err
	}

	var cfg Config
	if err := json.Unmarshal(data, &cfg); err != nil {
		return nil, err
	}
	return &cfg, nil
}

// Save writes config to disk
func (c *Config) Save() error {
	path := GetConfigPath()
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0750); err != nil {
		return err
	}

	data, err := json.MarshalIndent(c, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0600)
}

// IsConfigured returns true if sync is configured
func (c *Config) IsConfigured() bool {
	return c.Server != "" && c.Token != "" && c.DerivedKey != ""
}
```

**Step 3: Commit**

```bash
git add internal/config/ go.mod go.sum
git commit -m "feat: add sync configuration management"
```

---

## Task 2: Sync Engine

**Files:**
- Create: `internal/sync/sync.go`

**Implementation:**

```go
// ABOUTME: Sync engine for vault synchronization
// ABOUTME: Handles push/pull of changes to/from vault

package sync

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"github.com/harper/bbs/internal/config"
	"github.com/harper/bbs/internal/db"
	"github.com/harper/bbs/internal/models"
	"github.com/oklog/ulid/v2"
)

// ChangeType represents the type of change
type ChangeType string

const (
	ChangeUpsert ChangeType = "upsert"
	ChangeDelete ChangeType = "delete"
)

// EntityType represents the entity being changed
type EntityType string

const (
	EntityTopic      EntityType = "topic"
	EntityThread     EntityType = "thread"
	EntityMessage    EntityType = "message"
	EntityAttachment EntityType = "attachment"
)

// Change represents a queued change
type Change struct {
	ID        string     `json:"id"`
	Entity    EntityType `json:"entity"`
	EntityID  string     `json:"entity_id"`
	Op        ChangeType `json:"op"`
	Payload   string     `json:"payload"`
	CreatedAt time.Time  `json:"created_at"`
}

// Syncer handles synchronization
type Syncer struct {
	appDB   *sql.DB
	config  *config.Config
	enabled bool
}

// NewSyncer creates a new syncer
func NewSyncer(appDB *sql.DB) (*Syncer, error) {
	cfg, err := config.Load()
	if err != nil {
		return nil, err
	}

	return &Syncer{
		appDB:   appDB,
		config:  cfg,
		enabled: cfg.IsConfigured() && cfg.AutoSync,
	}, nil
}

// QueueTopicChange queues a topic change for sync
func (s *Syncer) QueueTopicChange(topic *models.Topic, op ChangeType) error {
	if !s.enabled {
		return nil
	}

	payload, _ := json.Marshal(topic)
	return s.queueChange(EntityTopic, topic.ID.String(), op, string(payload))
}

// QueueThreadChange queues a thread change for sync
func (s *Syncer) QueueThreadChange(thread *models.Thread, op ChangeType) error {
	if !s.enabled {
		return nil
	}

	payload, _ := json.Marshal(thread)
	return s.queueChange(EntityThread, thread.ID.String(), op, string(payload))
}

// QueueMessageChange queues a message change for sync
func (s *Syncer) QueueMessageChange(msg *models.Message, op ChangeType) error {
	if !s.enabled {
		return nil
	}

	payload, _ := json.Marshal(msg)
	return s.queueChange(EntityMessage, msg.ID.String(), op, string(payload))
}

func (s *Syncer) queueChange(entity EntityType, entityID string, op ChangeType, payload string) error {
	// For now, just log the change. Full vault integration would queue to vault.db
	change := Change{
		ID:        ulid.Make().String(),
		Entity:    entity,
		EntityID:  entityID,
		Op:        op,
		Payload:   payload,
		CreatedAt: time.Now(),
	}

	// TODO: Queue to vault database when fully integrated
	_ = change
	return nil
}

// Sync performs a full sync (push local changes, pull remote)
func (s *Syncer) Sync(ctx context.Context) error {
	if !s.config.IsConfigured() {
		return fmt.Errorf("sync not configured - run 'bbs sync login' first")
	}

	// TODO: Implement full vault sync when integrated
	return nil
}

// ApplyChange applies a remote change to local database
func (s *Syncer) ApplyChange(change *Change) error {
	switch change.Entity {
	case EntityTopic:
		return s.applyTopicChange(change)
	case EntityThread:
		return s.applyThreadChange(change)
	case EntityMessage:
		return s.applyMessageChange(change)
	}
	return nil
}

func (s *Syncer) applyTopicChange(change *Change) error {
	if change.Op == ChangeDelete {
		// Delete topic
		_, err := s.appDB.Exec("DELETE FROM topics WHERE id = ?", change.EntityID)
		return err
	}

	var topic models.Topic
	if err := json.Unmarshal([]byte(change.Payload), &topic); err != nil {
		return err
	}

	// Upsert topic
	_, err := s.appDB.Exec(`
		INSERT INTO topics (id, name, description, created_at, created_by, archived)
		VALUES (?, ?, ?, ?, ?, ?)
		ON CONFLICT(id) DO UPDATE SET
			name = excluded.name,
			description = excluded.description,
			archived = excluded.archived`,
		topic.ID.String(), topic.Name, topic.Description,
		topic.CreatedAt, topic.CreatedBy, topic.Archived)
	return err
}

func (s *Syncer) applyThreadChange(change *Change) error {
	if change.Op == ChangeDelete {
		_, err := s.appDB.Exec("DELETE FROM threads WHERE id = ?", change.EntityID)
		return err
	}

	var thread models.Thread
	if err := json.Unmarshal([]byte(change.Payload), &thread); err != nil {
		return err
	}

	_, err := s.appDB.Exec(`
		INSERT INTO threads (id, topic_id, subject, created_at, created_by, sticky)
		VALUES (?, ?, ?, ?, ?, ?)
		ON CONFLICT(id) DO UPDATE SET
			subject = excluded.subject,
			sticky = excluded.sticky`,
		thread.ID.String(), thread.TopicID.String(), thread.Subject,
		thread.CreatedAt, thread.CreatedBy, thread.Sticky)
	return err
}

func (s *Syncer) applyMessageChange(change *Change) error {
	if change.Op == ChangeDelete {
		_, err := s.appDB.Exec("DELETE FROM messages WHERE id = ?", change.EntityID)
		return err
	}

	var msg models.Message
	if err := json.Unmarshal([]byte(change.Payload), &msg); err != nil {
		return err
	}

	_, err := s.appDB.Exec(`
		INSERT INTO messages (id, thread_id, content, created_at, created_by, edited_at)
		VALUES (?, ?, ?, ?, ?, ?)
		ON CONFLICT(id) DO UPDATE SET
			content = excluded.content,
			edited_at = excluded.edited_at`,
		msg.ID.String(), msg.ThreadID.String(), msg.Content,
		msg.CreatedAt, msg.CreatedBy, msg.EditedAt)
	return err
}

// IsEnabled returns true if sync is enabled
func (s *Syncer) IsEnabled() bool {
	return s.enabled
}

// GetPendingCount returns the number of pending changes
func (s *Syncer) GetPendingCount() int {
	// TODO: Query vault.db for pending changes
	return 0
}
```

**Step 3: Add ulid dependency**

Run: `go get github.com/oklog/ulid/v2`

**Step 4: Commit**

```bash
git add internal/sync/ go.mod go.sum
git commit -m "feat: add sync engine for vault synchronization"
```

---

## Task 3: Sync CLI Commands

**Files:**
- Create: `cmd/bbs/sync.go`

**Implementation:**

```go
// ABOUTME: Sync CLI commands
// ABOUTME: Manages vault synchronization

package main

import (
	"fmt"

	"github.com/fatih/color"
	"github.com/harper/bbs/internal/config"
	"github.com/harper/bbs/internal/sync"
	"github.com/oklog/ulid/v2"
	"github.com/spf13/cobra"
)

var syncCmd = &cobra.Command{
	Use:   "sync",
	Short: "Manage vault synchronization",
	Long:  "Initialize, configure, and trigger vault synchronization.",
}

var syncInitCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize vault sync",
	RunE:  runSyncInit,
}

var syncStatusCmd = &cobra.Command{
	Use:   "status",
	Short: "Show sync status",
	RunE:  runSyncStatus,
}

var syncNowCmd = &cobra.Command{
	Use:   "now",
	Short: "Sync now",
	RunE:  runSyncNow,
}

var syncLoginCmd = &cobra.Command{
	Use:   "login",
	Short: "Login to sync server",
	RunE:  runSyncLogin,
}

var syncLogoutCmd = &cobra.Command{
	Use:   "logout",
	Short: "Logout from sync server",
	RunE:  runSyncLogout,
}

func init() {
	rootCmd.AddCommand(syncCmd)
	syncCmd.AddCommand(syncInitCmd, syncStatusCmd, syncNowCmd, syncLoginCmd, syncLogoutCmd)
}

func runSyncInit(cmd *cobra.Command, args []string) error {
	cfg, err := config.Load()
	if err != nil {
		return err
	}

	if cfg.DeviceID != "" {
		fmt.Printf("Already initialized with device ID: %s\n", cfg.DeviceID[:8])
		return nil
	}

	cfg.DeviceID = ulid.Make().String()
	cfg.VaultDB = config.GetVaultDBPath()
	cfg.AutoSync = true

	if err := cfg.Save(); err != nil {
		return err
	}

	color.Green("Initialized sync")
	fmt.Printf("Device ID: %s\n", cfg.DeviceID[:8])
	fmt.Printf("Vault DB: %s\n", cfg.VaultDB)
	fmt.Println("\nRun 'bbs sync login' to authenticate.")
	return nil
}

func runSyncStatus(cmd *cobra.Command, args []string) error {
	cfg, err := config.Load()
	if err != nil {
		return err
	}

	fmt.Println("Sync Status")
	fmt.Println("───────────")

	if cfg.DeviceID == "" {
		color.Yellow("Not initialized. Run 'bbs sync init' first.")
		return nil
	}

	fmt.Printf("Device ID: %s\n", cfg.DeviceID[:8])
	fmt.Printf("AutoSync: %v\n", cfg.AutoSync)

	if cfg.Server == "" {
		color.Yellow("Not logged in. Run 'bbs sync login' to authenticate.")
		return nil
	}

	fmt.Printf("Server: %s\n", cfg.Server)
	fmt.Printf("User: %s\n", cfg.UserID)

	syncer, err := sync.NewSyncer(dbConn)
	if err != nil {
		return err
	}

	pending := syncer.GetPendingCount()
	if pending > 0 {
		color.Yellow("Pending changes: %d", pending)
	} else {
		color.Green("All synced")
	}

	return nil
}

func runSyncNow(cmd *cobra.Command, args []string) error {
	syncer, err := sync.NewSyncer(dbConn)
	if err != nil {
		return err
	}

	if !syncer.IsEnabled() {
		return fmt.Errorf("sync not configured - run 'bbs sync login' first")
	}

	fmt.Println("Syncing...")
	if err := syncer.Sync(cmd.Context()); err != nil {
		return err
	}

	color.Green("Sync complete")
	return nil
}

func runSyncLogin(cmd *cobra.Command, args []string) error {
	cfg, err := config.Load()
	if err != nil {
		return err
	}

	if cfg.DeviceID == "" {
		return fmt.Errorf("not initialized - run 'bbs sync init' first")
	}

	// TODO: Implement interactive login flow
	// For now, just show what would happen
	fmt.Println("Login flow would:")
	fmt.Println("1. Prompt for server URL")
	fmt.Println("2. Prompt for email/password")
	fmt.Println("3. Prompt for BIP39 recovery phrase")
	fmt.Println("4. Derive encryption keys")
	fmt.Println("5. Store tokens and derived key")
	color.Yellow("\nFull vault integration pending.")

	return nil
}

func runSyncLogout(cmd *cobra.Command, args []string) error {
	cfg, err := config.Load()
	if err != nil {
		return err
	}

	cfg.Token = ""
	cfg.RefreshToken = ""
	cfg.TokenExpires = ""
	// Keep DerivedKey for re-login

	if err := cfg.Save(); err != nil {
		return err
	}

	color.Green("Logged out")
	return nil
}
```

**Step 2: Build and verify**

Run: `go build ./cmd/bbs && ./bbs sync --help`

**Step 3: Commit**

```bash
git add cmd/bbs/sync.go
git commit -m "feat: add sync CLI commands"
```

---

## Task 4: Whoami Command

**Files:**
- Create: `cmd/bbs/whoami.go`

**Implementation:**

```go
// ABOUTME: Whoami command
// ABOUTME: Shows current identity

package main

import (
	"fmt"

	"github.com/harper/bbs/internal/config"
	"github.com/harper/bbs/internal/identity"
	"github.com/spf13/cobra"
)

var whoamiCmd = &cobra.Command{
	Use:   "whoami",
	Short: "Show current identity",
	RunE:  runWhoami,
}

func init() {
	rootCmd.AddCommand(whoamiCmd)
}

func runWhoami(cmd *cobra.Command, args []string) error {
	id := identity.GetIdentity(identityFlag, "cli")
	fmt.Printf("Identity: %s\n", id)

	cfg, _ := config.Load()
	if cfg != nil && cfg.DeviceID != "" {
		fmt.Printf("Device: %s\n", cfg.DeviceID[:8])
	}
	if cfg != nil && cfg.IsConfigured() {
		fmt.Printf("Sync: enabled (server: %s)\n", cfg.Server)
	} else {
		fmt.Println("Sync: not configured")
	}

	return nil
}
```

**Step 2: Build and verify**

Run: `go build ./cmd/bbs && ./bbs whoami`

**Step 3: Commit**

```bash
git add cmd/bbs/whoami.go
git commit -m "feat: add whoami command"
```

---

## Phase 5 Complete Checklist

- [ ] `go build ./cmd/bbs` succeeds
- [ ] `./bbs sync init` initializes device
- [ ] `./bbs sync status` shows status
- [ ] `./bbs whoami` shows identity
